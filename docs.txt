1. What is Next.js?
    => Next.js is a framework for building web applications.
    => Build user interfaces using React components.
    => Next.js provides additional structure, features, and optimizations for your application.
    => Next.js also abstracts and automatically configures tooling for you, like bundling, compiling, and more.

2. Main features:
    > Routing: A file-system based router.
    > Rendering: Client-side and Server-side Rendering.
    > Data Fetching: Simplified data fetching with async|await support in React Components.
    > TypeScript: Improved support for TypeScript.

3. Installation:
    * npx create-next-app@latest

    What is your project named? my-app
    Would you like to use TypeScript? No / Yes
    Would you like to use ESLint? No / Yes
    Would you like to use Tailwind CSS? No / Yes
    Would you like to use `src/` directory? No / Yes
    Would you like to use App Router? (recommended) No / Yes
    Would you like to customize the default import alias? No / Yes

4. Structure:
    > app:
        layout.tsx      //The root layout
        page.tsx        //The root of the application

        globals.css
        page.module.css
        favicon         //Directly added

    > public:           //Store static assets such as images, fonts,...

5. app Routing Conventions:
    //Routing__files:
        layout      .js .jsx .tsx ==> Layout
        page        .js .jsx .tsx ==> Page
        loading     .js .jsx .tsx ==> Loading UI
        not-found   .js .jsx .tsx ==> Not Found UI
        error       .js .jsx .tsx ==> Error UI ({ error, reset })
        route       .js .ts       ==> API endpoint
        layout      .js .jsx .tsx ==> Layout

    //Nested__routes:
        folder/folder     ==> Nested route segment
        folder/[folder]   ==> Dynamic route segment
        (folder)          ==> Group routes without affecting routing

6. When to use Server and Client Components?
    > Server Component:
        / Fetch data.
        / Access backend resources.
        / Keep sensitive information on the server.
        / Keep large dependencies on the server.

    > Client Component:
        / Add interactivity and event listeners.
        / Use State and Lifecycle Effects.
        / Use browser-only APIs.
        / Use custom hooks that depend on state, effects, or browser-only APIs.

7. Using context in Client Components:
    ///:
        'use client';
        import { createContext } from 'react';
        export const NameContext = createContext();
        export default function NameProvider({ children }) {    
            return (
                <NameContext.Provider value="">
                    { children }
                </NameContext.Provider>
            );
        };

    ///:
        import NameProvider from '...';
        use it inside your layout.

        ==> With the provider rendered at the root, 
            all other Client Components throughout your app 
            will be able to consume this context.

8. Sharing data between Server Components:
    ==> Since Server Components are not interactive and therefore 
        do not read from React state, you don't need React context 
        to share data.

    ==> Instead, you can use native JavaScript patterns for common 
        data that multiple Server Components need to access.

9. App Router:
    1) Routing Fundamentals:
        _ Tree: A convention for visualizing a hierarchical structure.
        _ Subtree: Part of a tree, starting at a new root (first) and ending at the leaves (last).
        _ Root: The first node in a tree or subtree.
        _ Leaf: Nodes in a subtree that have no children.
        _ URL Segment: Part of the URL path delimited by slashes.
        _ URL Path: Part of the URL that comes after the domain (composed of segments).

    2) Defining Routes:
        * Root layout is required.
        * Layouts can be nested.
        * Layouts persist across routes and maintain state.
        * Templates create a new instance for each of their children on navigation.
    
    3) Modifying <head>:
        export const metadata = {
            title: '...',
            description: '...',
        }

10. Linking and Navigating:
    * <Link> Component
    * useRouter Hook

    ==> use usePathname() to determine if a link is active.
        const pathname = usePathname();
        const isActive = pathname.startsWith(link.href);

    ==> The useRouter hook allows you to programmatically change routes.
        const router = useRouter();
        router.push('/dashboard');

11. Dynamic Routes:
    ==> A Dynamic Segment can be created by wrapping a folder's name in 
        square brackets: [folderName]. For example, [id] or [slug].

    ==> Dynamic Segments are passed as the params prop to layout, page, 
        route, and generateMetadata functions.

    ==> Dynamic Segments can be extended to catch-all subsequent 
        segments by adding an ellipsis inside the brackets [...folderName].

    ==> Catch-all Segments can be made optional by including the parameter 
        in double square brackets: [[...folderName]].

    <==> The difference between catch-all and optional catch-all segments
        is that with optional, the route without the parameter is also matched.


X. TypeScript:
    ==> Types:
        { children }: { children: React.ReactNode }
        { error, reset }: { error: Error, reset: () => void }

Y. Fonts:
    import { Font } from 'next/font/google';
    const font = Font({ subsets: ['latin'], weight: ['400'] });
    className={ `${ font.className }` }